(Dis donc emacs, ceci est du -*-text-*- !)

$Id$


                    Liste des choses à faire
		    ========================


Parsing fichiers
================

 4. possibilité d'échapper [ ou ] dans les quotations de code
    (actuellement ce n'est pas possible et cela provoque des incohérences)

 5. Une commande pour rajouter une entrée dans l'index

 6. Eviter les erreurs du style un commentaire qui commence comme
    (*i... : mettre une synatxe plus stricte pour ces « commandes »
    ocamlweb (s,c et i). Suggestions :

    a) imposer qu'apres la lettre s,c ou i il n'y ait pas une lettre.
    b) demander une syntaxe plus explicite. par exemple (**s, (**i ou
       (**c 

 7. Rajouter une commande « latex only », par exemple (*l.... *). Ceci 
    est utile pour insérer du latex invisible. Par exemple :

    (*l \newcommand{\toto}{...} *)

    Actuellement, faire ceci fonctionne (la macro \toto est bien
    définie *) mais : si c'est un paragraphe de commentaire isolé cela
    insère des espaces, si c'est un commentaire de code cela fait
    apparaitre les (* et *) !

    Autre utilisation possible :

    let f .... =

       .... (*l \node{dest}{ *)  x  (*l } *) ....


       (*   notez que la variable x \node{orig}{ici}
       \line{->}{orig}{dest} est ... *)

Web (cross)
===========

 3. supprimer tout de même les modules et fonctions de Pervasives de l'index
    lorsque l'on utilise l'option --extern-defs ?

*4. Est-ce que les modules (correspondant aux fichiers) eux-mêmes doivent
    apparaître dans l'index global, ou doivent-ils apparaître dans un index
    particulier ?

  LEXERS:     Ca marche, mais c'est très très lent !
  -------
    cross.ml:
    let f' = if check_suffix f ".mll" then (chop_extension f) ^ ".ml" else f in

    web.ml:
    let lexer_after fmll fml l1 l2 =
      let (_,x1,y1) = Linenum.for_position fml l1 in
      let (_,x2,y2) = Linenum.for_position fmll l2 in
      (x1,y1) >= (x2,y2)
    
    et dans find_where on met 
    let after = 
      if check_suffix w.w_filename ".mll" then 
        lexer_after w.w_filename ((chop_extension w.w_filename) ^ ".ml")
      else 
        (>=)

    main.ml: dans what_file
    if check_suffix f ".ml" or check_suffix f ".mll" then


Document LaTeX
==============

 1. underscore plus fin dans les identificateurs

 3. Index des modules

 4. « rule » est composé comme un mot-clé à cause des fichiers LEX,
    mais ce n'est pas correct ailleurs.	idem pour « parse »

 5. Les espaces verticaux entre paragraphes sont pas terriblement au
    point, surtout avec hevea. Il faudrait revoir l'utilisation de
    \ocwnl et \medskip. Peut-etre remplacer \medskip par une macro
    customisable \ocwnewpar. Par exemple, mettre un \medskip avant un
    \ocwinterface n'est pas une bonne idée si \ocwinterface est un
    \section.

 6. (Claude) Possibilité d'insérer du code caml dans les commentaires :
    cela est utile pour citer des exemples d'utilisation des
    fonctions.  Par exemple :

    (* [betared t] retourne la forme normale du lambda-terme [t]. Par
       exemple,
       \begin{code}
       (betared 
         (App 
	   (App
	     (Lambda "x",(App .... ))
              ....)
	    ...)
	  ..)
       \end{code}

    *)

    val betared : lambda -> lambda;;



    Actuellement, utiliser des crochets [ ... ] ne marche pas car le
    contenu n'est plus formaté en respectant les passages a la
    ligne. La solution temporaire que j'ai utilisée est verbatim, mais
    ce n'est pas joli.

    (Demandé aussi par Pierre)
    
Documentation ocamlweb
======================

